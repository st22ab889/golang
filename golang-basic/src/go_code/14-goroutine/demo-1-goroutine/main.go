/*
1.Go语言中实现并行或并发,就需要使用到goroutine.就是说将一个任务分配给多个goroutine去完成.

2.goroutine基本介绍 -- 进程和线程说明
	(1):进程就是程序在操作系统中的一次执行过程,是系统进行资源分配和调度的基本单位.
	(2):线程是进程的一个执行实例,是程序执行的最小单元,它是比进程更小的能独立运行的基本单位.
	(3):一个进程可以创建和销毁多个线程,同一个进程中的多个线程可以并发执行.
	(4):一个程序至少有一个进程,一个进程至少有一个线程.

3.goroutine基本介绍 -- 并发和并行
	(1):多线程程序在单核上运行就是并发.
	比如在一个CPU上有10个线程,每个线程执行10毫秒(进行轮询操作),看着好像10个线程都在运行,但从微观上看,在某一个时间点看,其实只有一个线程在执行,这就是并发.
	(2):多线程程序在多核上运行就是并行.
	比如有10个CPU, 有10个线程,每个线程执行10毫秒(各自在不同CPU上执行),看着好像10个线程都在运行,但从微观上看,在某一个时间点看,也同时有10个线程在执行,这就是并行.

4.goroutine基本介绍 -- Go协程和Go主线程
	(1):Go主线程(有程序员直接称为线程/也可以理解成进程):一个Go线程上,可以起多个协程,可以理解为协程就是轻量级的线程(编译器做优化).
	(2):Go协程的特点:
		有独立的栈空间
		共享程序堆空间
		调度由用户控制
		协程是轻量级的线程

5.goroutine-快速入门小结
	(1):主线程是一个物理线程,直接作用在CPU上.是重量级的,非常耗费资源.
	(2):协程从主线程开启的,是轻量级的线程,是逻辑态.对资源消耗相对小.
	(3):Golang的协程机制是重要的特点,可以轻松的开启上万个协程.
		其它编程语言的并发机制是一般基于线程的,开启过多的线程,资源耗费大,这里就凸显Golang在并发上的优势.
*/

package main

import (
	"fmt"
	"strconv"
	"time"	
)

/*
goroutine-快速入门:
在主线程(可以理解成进程)中,开启一个goroutine,该协程每隔1秒输出"Hello Goroutine"
主线程中也每隔一秒输出"Hello Golang",输出10次后退出程序,要求主线程和goroutine同时执行
*/
func first () {

	go test() // 开启一个协程
	// 如果主线程退出了,则协程即使还没有执行完毕也会退出
	// 协程也可以在主线程没有推出前就自己结束,比如完成了自己的任务

	for i := 1; i <= 10; i++ {
		fmt.Println(" main() Hello Golang" + strconv.Itoa(i))
		time.Sleep(time.Second)
	}
}

func test() {
	for i := 1; i <= 10; i++ {
		fmt.Println("test () Hello Goroutine " + strconv.Itoa(i))
		time.Sleep(time.Second)
	}
}

func main() {
	first ()
}
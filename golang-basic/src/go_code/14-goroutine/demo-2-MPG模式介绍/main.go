/*
1.goroutine的调度模型-MPG模式基本介绍:
	(1). M:操作系统的主线程(是物理线程)
	(2). P:协程执行需要的上下文
	(3). G:协程

2.goroutine的调度模型-MPG模式运行的状态1
	(1). 当前程序有三个M,如果三个M都在一个CPU上运行,就是并发,如果在不同的CPU运行就是并行
	(2). M1、M2、M3正在执行一个G, M1对协程队列有3个, M2对协程队列有3个, M3对协程队列有2个 
	(3). 从图中可以看到:Go的协程是轻量级的线程,是逻辑态的,Go可以容易的起上万个协程.
	(4). 其它语言 c/java 等的多线程,往往是内核态的,比较重量级,几千个线程可能耗光CPU.

3.goroutine的调度模型-MPG模式运行的状态2
	(1). 分成两个部分来看
	(2). 原来的情况是M0主线程正在执行G0协程,另外有三个协程在队列等待.
	(3). 比如G0协程堵塞,比如读取文件或者数据库等.
	(4). 这时就会创建M1主线程(也有可能是从已有的线程池中取出M1),并且将等待的3个协程挂到M1下开始执行,M0的主线程下的G0仍然执行文件IO的读写.
	(5). 这样的MPG调度模式,可以既让G0执行,同时也不会让队列的其它协程一直阻塞,仍然可以并发/并行执行.
	(6). 等到G0不阻塞了,M0会被放到空闲的主线程继续执行(从已有的线程池中取),同时G0又会被唤醒.

*/

package main

import (
	_ "fmt"
)

func main() {

}
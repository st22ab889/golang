
/*
对于整数有四种表示方式:
	二进制: 0和1表示,满2进1. 在Golang中不能直接使用二进制来表示一个整数,它沿用了C的特点
	十进制: 0-9,满10进1
	八进制: 0-7,满8进1.以数字0开头表示
	十六进制: 0-9以及A-F,满16进1.以0x或0X开头表示,此处A-F不区分大小写

二进制在运算中的说明:二进制是逢2进位的进位制,0、1是基本算符.
	现代的电子计算机技术全部采用的是二进制,因为它只使用0、1两个数字符号,非常简单方便,易于电子方式实现.
	计算机内部处理的信息,都是采用二进制数来表示.
	二进制(Binary)数用0和1两个数字及其组合来表示任何数,进位规则是"逢2进1",数字1在不同的位上代表不同的值,按从右至左的次序,这个值以二倍递增.
	在计算机内部,运行各种运算时,都是以二进制的方式来运行.

原码、反码、补码:
	对于有符号的而言
		1.二进制的最高位是符号位:0表示正数,1表示负数
			1 	==> 0000 0001
			-1	==> 1000 0001
		2.正数的原码、反码、补码都一样
			1 ==> 原码[0000 0001]  ==>  反码[0000 0001]  ==>  补码[0000 0001]
		3.负数的反码 = 它的原码符号位不变,其他位取反
		4.负数的补码 = 它的反码 + 1
		   -1 ==> 原码[1000 0001]  ==>  反码[1111 1110]  ==>  补码[1111 1111]
		5.0的反码、补码都是0
		6.在计算机运算的时候,都是以补码的方式来运算的,因为在计算机的世界中没有减法
			比如: 1+1、1-1 = 1 + (-1)
			示例: 1-2 = 1 + (-2)
				1的原码是 0000 0001, 补码也是 0000 0001
				-2的原码是 1000 0010, 反码是 1111 1101 , 补码是 1111 1110
				1 + (-2) = 0000 0001 + 1111 1110 = 1111 1111   // 补码运算的结果是补码
				补码[1111 1111] ==> 反码[1111 1110] ==> 原码[1000 0001] ==> 对应的十进制是 -1 	// 负数的反码 = 负数的补码 - 1, 负数的原码码 = 它的反码符号位不变,其他位取反
*/

package main
import(
	"fmt"
	_ "unsafe"
	_ "strconv"
)

func main() {

	// 二进制输出
	var i int = 5
	fmt.Printf("%b \n", i)		// 101

	// 八进制: 0-7, 满8进1,以数字0开头表示
	var j int = 011	// 011 = 9
	fmt.Println("j = ", j)		// j =  9

	// 十六进制: 0-9以及A-F, 满16进1,以0x或0X开头表示
	var k int = 0x11	// 0x11 => 16 + 1 = 17
	fmt.Println("k = ", k)		// k =  17

	toDecimal()

	decimalToOther()

	binaryToOther()

	toBinary()

	// 位运算
	bitOperator()
}	

func toDecimal() {

	// 二进制转十进制
	// 规则: 从最低位开始(右边的),将每个位上的数提取出来,乘以2的(位数-1)次方,然后求和
	// 1011 = 1 * 1 + 1 * 2 + 0 * 2 * 2 + 1 * 2 * 2 * 2 = 11

	// 八进制转十进制
	// 规则: 从最低位开始(右边的),将每个位上的数提取出来,乘以8的(位数-1)次方,然后求和
	// 0123 = 3 * 1 + 2 * 8 + 1 * 8 * 8 = 83

	// 十六进制转十进制
	// 规则: 从最低位开始(右边的),将每个位上的数提取出来,乘以16的(位数-1)次方,然后求和
	// 0x34A = 10 * 1 + 4 * 16 + 3 * 16 * 16 = 842
}

func decimalToOther() {
	// 十进制转二进制
	// 规则: 将该数不断除以2,直到商为0为止,然后将每步得到的余数倒过来,就是对应的二进制

	// 十进制转八进制
	// 规则: 将该数不断除以8,直到商为0为止,然后将每步得到的余数倒过来,就是对应的八进制

	// 十进制转十六进制
	// 规则: 将该数不断除以16,直到商为0为止,然后将每步得到的余数倒过来,就是对应的十六进制
}

func binaryToOther(){

	// 二进制转八进制
	// 规则: 将二进制数每三位一组(从低位开始组合),转成对应的八进制数即可

	// 二进制转十六进制
	// 规则: 将二进制数每四位一组(从低位开始组合),转成对应的十六进制数即可

}

func toBinary(){

	// 八进制转二进制
	// 规则: 将八进制数每一位,转成对应的一个3位的二进制数即可.
	// 0237 = 010011111 = 10011111
		
	// 十六进制转二进制
	// 规则: 将十六进制数每一位,转成对应的一个4位的二进制数即可.
	// 0x237 =001000110111 = 1000110111
}	

func bitOperator() {

	/*
	Golang中有3个位运算,分别是:&(按位与)、|(按位或)、^(按位异或),运算规则如下:
		&(按位与): 两位全为1,结果位1,否则为0
			2 的补码 0000 0010
			3 的补码 0000 0011
			2&3		 0000 0010 = 2
		|(按位或): 两位有一个为1,结果为1,否则为0
			2 的补码 0000 0010
			3 的补码 0000 0011
			2|3		 0000 0011 = 3
		^(按位异或): 两位一个为0,一个为1,结果为1,否则为0
			-2 的原码 1000 0010 ==> 反码 1111 1101 ==> 补码 1111 1110
			-2 的补码	1111 1110
			2  的补码	0000 0010									
			-2^2的补码	1111 1100 ==> 反码 1111 1011  ==> 原码 1000 0100 ==> 十进制 -4  // 运算的结果是补码,需要转回原码
			
	Golang中有2个移位运算符:
		右移运算符 >> : 低位溢出,符号位不变,并用符号位补溢出的高位
			a := 1 >> 2 	// 0000 0001 右移2位 ==> 0000 0000 = 十进制 0
		左移运算符 << : 符号位不变,低位补0
			c := 1 << 2		// 0000 0001 左移2位 ==> 0000 0100 = 十进制 4 
	*/

	fmt.Println("2&3=", 2&3)	// 2&3= 2 
	fmt.Println("2|3=", 2|3)	// 2|3= 3
	fmt.Println("2^3=", 2^3)	// 2^3= 1
	fmt.Println("-2^2=",-2^2)	// -2^2= -4

	a := 1 >> 2 
	c := 1 << 2
	fmt.Println("a=", a, ", c=", c)		// a= 0 , c= 4
}

